                                                                     # 02.09.2025 вторник


#  Типы данных
12
100 # Числовой тип данных

0.5
9.2 # Тип данных float

"hello world"
"Привет мир" # тип данных строка

# Арифметические операторы
# + - * / // % **

# Операторы сравнения
# > < >= <= == !=


# print() - функция
# Функция - это определенное действие
print(5 + 5)
print(2 - 1)
print(5 * 100)
print(32 / 12)
print(5 + 10 / 2 * 300000 - 300)


# int() - функция преобразования к целому числу
print(int(5.5))
print(int(100.99))
print(int("123"))
print(int("456"))

# float() - функция преобразования к числу с плавающей точкой
print(float(5))
print(float(100))
print(float("123.45"))
print(float("456.78"))

# str() - функция преобразования к строковому типу
print(str(5))
print(str(100))
print(str(123.45))
print(str(456.78))

# 'hello'
# "hello"
# '''hello'''
# """hello"""

# bool() - тип данных имеющий два значения True (1) и False (2)
print(bool(1)) # True
print(bool(0)) # False
print(5 > 2) # True
print(5 < 2) # False
print(5 == 5) # True
print(5 != 5) # False
print(5 >= 5) # True
print(5 <= 5) # True


# Горячие клавиши
# ctrl + w             -закрыть вкладку 
# ctrl + t             - открыть новую вкладку
# ctrl + shift + t     - возврат закрытой вкладки
# ctrl + c             - копирование
# ctrl + a             - выделить все
# ctrl + x             - вырезать
# ctrl + v             - вставить
# ctrl + f             - поиск по символам
# ctrl + z             - возврат
# ctrl + shift + z     - возврат возврата
# alt + tab            - переключение между окнами
# shift + знак вверх вниз право лево - выделяем символы 
# shift + contrl + знак вверх вниз право лево - выделяем слова









                                                                    #  04. 09. 2025 четверг

# Переменные

# Переменная - хранилище для данных в Python(для строк, чисел, float)
# Схема: название_переменной = значение_переменной(строка, число, float)
# переменная регистрозависима
# or - "или" and - "и" not - "не" - логические операторы
name = "alex"
name = "david"
Name = "Захро"

age = 25

print(name)
print(Name)
print(age)

# Переменные могут перезаписываться

balance = 5000

balance = 3000 # balance становится равным не 5000, а 3000

print(balance - 500) # выведет 2500

balance = 1000 # balance становится равным не 3000, а 1000

print(balance) # выведет 1000

# input() - функция ввода данных с клавиатуры что онаделает -
# int()


# типы данных
# int - целое число (1, 2, 3, 100, -50)
# int- это целые числа, которые могут быть положительными или отрицательными, включая ноль.
# Примеры: -10, 0, 25, 1000

# float - число с плавающей точкой (1.5, 2.7)
# float - это числа, которые имеют десятичную точку и могут представлять как целые, так и дробные значения.
# Примеры: -3.14, 0.0, 2.718, 100.5

# str - строка ("hello", "привет", "123", "True")
# string - это последовательность символов, заключенных в кавычки (одинарные, двойные или тройные).
# Примеры: "Hello, World!", 'Python3', """This is a multi-line string."""

# bool - булевый тип данных (True, False)   
# boolean - это логический тип данных, который может принимать только два значения: True (истина) или False (ложь).
# Примеры: True, False

# list - список [1, 2, 3, "hello", True]
# list - это упорядоченная коллекция элементов, которые могут быть разного типа (числа, строки, другие списки и т.д.).
# Примеры: [1, 2, 3], ["apple", "banana", "cherry"], [1, "two", 3.0, True]

# tuple - кортеж (1, 2, 3, "hello", True )
# tuple - это упорядоченная и неизменяемая коллекция элементов, которые могут быть разного типа.
# Примеры: (1, 2, 3), ("a", "b", "c"), (1, "two", 3.0, False)

# dict - словарь {"name": "alex", "age": 25}
# dict - это неупорядоченная коллекция пар "ключ-значение", где каждый ключ уникален.
# Примеры: {"name": "Alice", "age": 30}, {"city": "New York", "population": 8000000}

# set - множество {1, 2, 3, "hello", True}
# set - это неупорядоченная коллекция уникальных элементов.
# Примеры: {1, 2, 3}, {"apple", "banana", "cherry"}, {1, "two", 3.0}

# frozenset - неизменяемое множество frozenset({1, 2, 3})
# frozenset - это неизменяемая версия множества (set), которая не позволяет изменять свои элементы после создания.
# Примеры: frozenset({1, 2, 3}), frozenset({"apple", "banana", "cherry"})




# Ввод данных и их вывод
# input() - функция ввода данных с клавиатуры
name = input("Введите ваше имя: ")
age = input("Введите ваш возраст: ")
learning = input("что вы изучаете?: ")
like = input("что вам нравится?: ")
print("Ваше имя:", name)
print("Ваш возраст:", age)
print("Ваше имя:" + name + ", ваш возраст:" + age)
print("Привет " + name + ", тебе " + age + " лет, ты изучаешь " + learning + " и тебе нравится " + like)









                                                                        #05.09.2025 пятница 

#Верблюжий_регист - camelCase - первая буква маленькая, каждое новое слово с большой буквы
# Пример: myVariableName
#Змеиный_регист - snake_case - все буквы маленькие, слова разделены нижним подчеркиванием
# Пример: my_variable_name

# Правила при создании переменных

# Вызовет ошибку!
# 12 = 5
# 1name = "ahmed"
# "a" = 5
# my-name = "john"
# my name = "john"
# my.name = "john"
# my*name = "john"
# my(name) = "john"
# my+name = "john"
#my=name = "john"
# название переменной не должно совпадать с ключевыми словами Python
# и не должно содержать спецсимволы кроме _ (нижнее подчеркивание)


# Множественное присваивание
myname, myage, mycity = "alex", 25, "NY"
print(myname)
print(myage)
print(mycity)
print(myname, myage, mycity)

# В названии переменной можно использовать только буквы, цифры и _
# Переменная не может начинаться с цифры



# Условия

# Условия - это проверка определенного условия и выполнение определенного действия в зависимости от результата проверки
# Ключевые слова условий:
# if - если
# else - иначе (все остальные случаи)
# elif - иначе если (проверка другого условия если первое не подошло)


# схема:
# if условие:
#     действие если условие верно
# elif другое_условие:
#     действие если другое_условие верно
# else:
#     действие если ни одно из условий не верно


# Примеры:
age =int(input("Введите ваш возраст: "))

if age >= 18:
    print("Вы совершеннолетний")
elif age <10:
    print("Вы ребенок")
else:
    print("Вы несовершеннолетний")










                                                                # 08.09.2025 понедельник

# Конкетенация строк
# Конкатенация - это объединение строк
# Схема:
# строка1 + строка2 + строка3 + ...
# Пример:
name = input("Введите ваше имя: ")
age = input("Введите ваш возраст: ")
print("Привет " + name + ", тебе " + age + " лет")
print("Привет", name, "тебе", age, "лет") # через запятую          

# Конкатенация строк с числами
# str() - функция преобразования к строковому типу

name = "john"
prof = "student"
age = 25
bio = "my name is " + name + ", i am " + prof  + " and i am " + str(age) + " years old"
# конкатенация строк - это склеивание строк с помощью +
print(bio)

# индексы - это порядковый номер элемента в строке
# индексы начинаются с 0

bio2 = "my name is {0}, i am {1} and i am {2} years old".format(name, prof, age)
print(bio2)


# f строки - это форматированные строки
bio3 = f"my name is {name}, i am {prof} and i am {age} years old"
print(bio3)

# f строки - это самый удобный способ форматирования строк
# в f строках можно использовать любые выражения внутри {}




# Индекс 
# Индекс - это файл, который выполняется первым в папке.
# Обычно в нём находится основная логика программы. 
# В данном случае, он просто импортирует и выполняет код из других файлов в той же папке.
# Пример


#      "0123456789 "
name = "john, ahmed, alex"

print(name[-1:-15]) # xela ,demha ,nhoj - строка в обратном порядке   
print(name[1])  # o
print(name[2])  # h
print(name[3])  # n
print(name [0] + name[1] + name[2] + name[3])  # john


# cрезы строк - это получение части строки
# схема: 
# строка[начало:конец:шаг]
# начало - индекс с которого начинается срез (включительно)
# конец - индекс на котором заканчивается срез (не включительно)
# шаг - через сколько символов брать символы (по умолчанию 1)


print(name[0:2])  # jo - символы с индексом 0 и 1 (2 не включительно)
print(name[:4])  # john - если начало не указано, то срез начинается с 0 индекса
print(name[0:])  # john, ahmed, alex - вся строка
print(name[0:10])  # john, ahm
print(name[0:10:2])  # jh a

# реверс строки  
print(name[::-1])  # xela ,demha ,nhoj - строка в обратном порядке
print(name[::-2])  # xaem,ea,nj - строка в обратном порядке через один символ
print(name[-1])    # x - последний символ строки

name = " Привет я ахмед !"
print(name[0:17:3])
print(name[0])  # срез строки [начало:конец:шаг]


# Методы строк
# Методы - это функции которые принадлежат определенному типу данных
# Методы строк - это функции которые принадлежат строковому типу данных
# Схема:
# строка.метод(аргументы)
name = " john, ahmed, alex "
print(name.upper())  # JOHN, AHMED, ALEX - все буквы заглавные
print(name.lower())  # john, ahmed, alex - все буквы строчные
print(name.title())  # John, Ahmed, Alex - каждое слово с заглавной буквы
print(name.strip())  # john, ahmed, alex - удаляет пробелы в начале и конце строки
print(name.replace("a", "A"))  # john, Ahmed, Alex - заменяет все буквы a на A схема: строка.replace(старое_значение, новое_значение)
print(name.split(","))  # [' john', ' ahmed', ' alex '] - разбивает строку по заданному символу и возвращает список
print(name.join())  #  j o h n ,   a h m e d ,   a l e x   - объединяет все символы строки с заданным символом между ними
print(name.find("ahmed"))  # 7 - возвращает индекс первого вхождения
print(name.count("a"))  # 2 - возвращает количество вхождений
print(name.startswith(" j"))  # True - проверяет начинается ли строка с заданного символа
print(name.endswith("x "))  # False - проверяет заканчивается ли строка заданным символом
print("a" in name)  # True - проверяет есть ли заданный символ в строке
print("z" in name)  # False - проверяет есть ли заданный символ в
print("a" not in name)  # False - проверяет нет ли заданного символа в строке
print("z" not in name)  # True - проверяет нет ли заданного символа в строке

# методы списков
 

                                                                           # 09.09.2025 вторник
# Задание 1:
# Написать программу для военкомата, которая запрашивает у пользователя его возраст 

age = int(input("Введите ваш возраст: "))
if age < 16:
    print("Вы еще молоды, вам рано в армию.")
elif age >= 16 and age < 18:
    print("Готовся, скоро в армию.")
elif age >= 18 :
    print("В армию пора!")
elif age > 40:
        print("пора на пенсию.")
elif age > 60:
            print("Отдыхай.")


                                                                                   # 10.09.2025   среда  

#  Сделать   программу которая принимает число и показывать что она четная или не четная

num = int(input("Введите число: "))
if num % 2 == 0:
    print("Число четное.")
else:
    print("Число нечетное.")



# Списки - list - тип данных, изменяемый ,который может хронить в себе разные типы данных,пишется через квадратные скобки []
# Списки - это 

variable = [ 34, 456.56 , "Купить ноут" , True , "Ahmed" , "Alua"]
variable.append("Billi") # Добовляет новые значения в конце

variable.remove(34)

variable.insert(4,"gena")

print(variable.index("Ahmed"))

print(variable)

print(type(variable))





                                                                      # 12.09.2025 Пятница
                
# list - список-  это изменяемая упорядоченная коллекция элементов. []
# Пример:
my_list = [1, 2, 3, "apple", True] 
my_list[2] = "Sasha" # можем менять
print(my_list)

# tuple - картеж - это неизменяемая упорядоченная коллекция элементов.()
# Пример:
my_tuple = (10, 20, "banana", False)
# my_tuple [2] = "Ahmed" не можем менять
print(my_tuple)

# set - множества -  это изменяемая неупорядоченная коллекция уникальных элементов.{}
# Пример:
my_set = {1, 2, 3, "orange", True}
my_set[2] = "Apple" # Можем менять
print(my_set)


# set.add(element) - добавляет элемент в множество. Если элемент уже есть, ничего не происходит.
example_set = {1, 2, 3}
example_set.add(4)
print(example_set)  # {1, 2, 3, 4}

# set.remove(element) - удаляет элемент из множества. Если элемента нет, возникает ошибка KeyError.
example_set.remove(2)
print(example_set)  # {1, 3, 4}

# set.discard(element) - удаляет элемент из множества. Если элемента нет, ошибки не возникает.
example_set.discard(10)
print(example_set)  # {1, 3, 4}

# set.pop() - удаляет и возвращает случайный элемент из множества.
removed_element = example_set.pop()
print(removed_element)  # Например, 1
print(example_set)      # Оставшиеся элементы, например {3, 4}



                                                                               # 15.09.2025 Понедельник

# Циклы

# Цикл — это конструкция, которая позволяет повторять определённые действия несколько раз.
# В Python есть два основных типа циклов: for и while.

# Цикл for — используется для перебора элементов последовательности (списка, строки, диапазона и т.д.)
# Пример:
for i in range(5):
    print("Цикл for, шаг:", i)

# Цикл while — выполняет действия, пока условие истинно.
# Пример:
count = 0
while count < 5:
    print("Цикл while, шаг:", count)
    count += 1



#  for - переменная in последовательность 

# Цикл for (для)

# пример отсчета от 1 до 10 на while
x = 1

while x <= 10:
  print(x)
  x = x + 1

# Пример вывода букв из строки на while
word = "apple"
index = 0

while index < len(word):
  print( word[index] )
  index = index + 1

# for переменная in последовательность:
#   код

# range(старт, конец, шаг) - создает последовательность чисел
# Пример: range(1, 6) -> 1, 2, 3, 4, 5

# пример
for i in range(3, 8): # 3, 4, 5, 6, 7
  print(i)

# for обратный отсчет
for i in range(5, 0, -1): # 5, 4, 3, 2, 1
  print(i)

# for по строке
word = "apple"

for i in word:
  print(i)

# for с шагом 2
for i in range(0, 11, 2):
  print(i)

# Условия внутри for
for i in range(1, 11):
  if i % 2 == 0:
    print(i)

# Таблица умножения
for a in range(1, 10):
  for b in range(1, 10):
    print(f"{a} * {b} = {a * b}")
  print("========")

# Таблица умножения на определенное число
x = int(input("Введите число: "))

for i in range(1, 10):
  print(f"{x} * {i} = {x * i}")



# Примеры с методами строк
q = []
for w in range (1,101,2) :
    q.append(w)

print(q)

#  2-ой пример
q = "a1p2p3l4e"
w = []
for e in q :
    if e.isdigit():
        w.append(e)
print(w)


#  Пример со списком

q = ["ahmed","ahMed","Ahmed"]
w = []

for l in q:
    w.append(l.upper())
print(w)


#  dic - dictionery - словари {key:value}
q = {
    "ahmed":19,
    "adilet":24,
    "Gena": 34,
}

for n,v in q.items():
    print(n,v+1)

# Дальше мы толко практиковались до : 25.09.2025

                                                            # 25.09.2025 Четверг

#  Исключение - try except
  
# Исключение - это ошибка, которая возникает во время выполнения программы.
# try - попытка выполнить код
# except - обработка ошибки, если она возникла
# finally - блок кода, который выполняется в любом случае, независимо от того, возникла ошибка или нет

# Схема:
# try:
#     код, который может вызвать ошибку
# except ТипОшибки:
#     код, который выполняется, если возникла ошибка
# finally:
#     код, который выполняется в любом случае
# Пример:
try:
    x = int(input("Введите число: "))
    y = 10 / x
    print("Результат:", y)
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")
except ValueError:
    print("Ошибка: Введите корректное число!")
finally:
    print("Конец программы.")

# популярные типы ошибок :
# ZeroDivisionError - деление на ноль
print(10 / 0)  # Ошибка

# ValueError - неверное значение
int("abc")  # Ошибка

# IndexError - выход за пределы списка
lst = [1, 2, 3]
print(lst[5])  # Ошибка

# KeyError - ключ не найден в словаре
d = {"a": 1}
print(d["b"])  # Ошибка

# TypeError - неверный тип данных
print("abc" + 5)  # Ошибка

# FileNotFoundError - файл не найден
open("nofile.txt")  # Ошибка

# ImportError - ошибка импорта модуля
# import notamodule  # Ошибка

# NameError - переменная не определена
# print(xyz)  # Ошибка

                                                                # 26.09.2025

# Функции 
# Функция — это именованный блок кода, который можно вызывать многократно.
# Функции помогают:
# 1. Избежать повторения кода.
# 2. Сделать программу более читаемой.
# 3. Упростить тестирование и отладку.
# 4. Разделить программу на логические части.

# Встроенные функции — это функции, которые уже есть в Python:
# =(), input(), int(), str(), float(), len(), type(), range(), sum(), min(), max(), abs(), round(), sorted(), list(), dict(), set(), tuple(), help(), dir(), zip(), map(), filter(), enumerate(), open(), pow(), all(), any(), chr(), ord(), id(), eval(), exec(), bin(), hex(), oct(), bool(), slice(), reversed(), next(), iter(), super(), isinstance(), issubclass(), globals(), locals(), vars(), hasattr(), getattr(), setattr(), delattr(), hash(), memoryview(), object(), property(), staticmethod(), classmethod(), format(), compile(), complex(), bytes(), bytearray(), frozenset(), callable(), ascii(), repr(), input(), print(), exit(), quit()

# Пользовательские функции — это функции, которые создаёт сам программист.
# Определение функции:
# def имя_функции(аргументы):
  # тело функции
  # return результат

# Пример пользовательской функции:
# def greet(name):
  # print(f"Привет, {name}!")

# greet("Ахмед")

# функции
# 1 встроенные функции
# print() input() int() float() bool() str() set()
# tuple() len() type()
# 2 пользовательские функции - то что мы напишем через def
# list() dict()
# Функция - это кусочек кода который мы можем один раз написать, а потом вызывать и использовать сколько угодно.
# Она помогает:
# 1) не повторять один и тот же код
# 2) удобно передавать данные внутрь и получать результат
# 3) делает программу аккуратнее и понятнее
# def - используется только когда создаем функцию, а вызов функции делает через имя функции и круглые скобки ()


#  Примеры 
# Пример встроенной функции
numbers = [1, 2, 3, 4, 5]
print("Сумма чисел:", sum(numbers))  # sum() - встроенная функция для суммы элементов

# Пример пользовательской функции
def greet(name):
  print(f"Привет, {name}!")

greet("Ахмед")

# Пример функции без аргументов
def hello():
  print("Привет, мир!")

#  
def minimal(l):
  min1 = l[0]
  for q in l:
    if q < min1:
      min1 = q
  return min1

num = [1, 2, 7, 4, 8, 6, 9, 3]
print("Минимальное значение:", minimal(num))

# Программа калькулятор: + - * /
def calculator():
  while True:
    try:
      a = float(input("Введите первое число: "))
    except ValueError:
      print ("Только числа!")
      continue
    op = input("Введите операцию (+, -, *, /): ")
    try:
        b = float(input("Введите второе число: "))
    except ValueError:
        print("Только числа!")
        continue
  
    if op == "+":
        print("Результат:", a + b)
    elif op == "-":
        print("Результат:", a - b)
    elif op == "*":
        print("Результат:", a * b)
    elif op == "/":
          try:
           print("Результат:", a / b)
          except ZeroDivisionError:
             print("На ноль делить нельзя")
             continue
    else:
        print("Ошибка: неизвестная операция.")
  
calculator()



  # import - это ключевое слово в Python, которое используется для подключения (импорта) модулей и библиотек.
  # Модуль — это файл с кодом на Python, который содержит функции, переменные и классы, чтобы их можно было использовать в других программах.
  # С помощью import можно использовать готовые функции и инструменты из стандартной библиотеки Python или сторонних пакетов.
  # Пример:
  # import math  # импортируем модуль math
  # print(math.sqrt(16))  # используем функцию sqrt из модуля math, результат: 4.0
# способы :
  # 1- import Класная работа - импортирует файл 
  # 2- from Классная работа import calculator

 

                                                       #07.10.2025 вторник

# abs - эта функция возвращает абсолютное значение числа, то есть его величину без учета знака.
print(abs(-5))  # Выведет: 5
print(abs(3.14))  # Выведет: 3.14


# all - эта функция возвращает True, если все элементы итерируемого объекта (например, списка или кортежа) истинны (не равны False или None). Если хотя бы один элемент ложен, возвращается False.
print(all([1, 2, 3]))  # Выведет: True
print(all([1, 0, 3]))  # Выведет: False
print(all([]))  # Выведет: True (пустой список считается истинным)

# any - эта функция возвращает True, если хотя бы один элемент итерируемого объекта истинен. Если все элементы ложны, возвращается False.
print(any([0, 0, 3]))  # Выведет: True 



                                                    # 14.10.25 вторник


# lambda - это способ создания анонимных функций в Python. Анонимные функции - это функции, которые не имеют имени и обычно используются для кратковременных операций.
# Синтаксис lambda функции:
# lambda аргументы: выражение
# Пример:
add = lambda x, y: x + y
print(add(3, 5))  # Выведет: 8
# Пример использования lambda функции с функцией map
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(squared)  # Выведет: [1, 4, 9, 16, 25]

# Пример использования lambda функции с функцией filter
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # Выведет: [2, 4]
# Пример использования lambda функции с функцией sorted
points = [(1, 2), (3, 1), (5, 4), (2, 3)]
sorted_points = sorted(points, key=lambda point: point[1])
print(sorted_points)  # Выведет: [(3, 1), (1, 2), (2, 3), (5, 4)]
# lambda функции полезны для кратковременных операций, когда не нужно создавать полноценную функцию с именем.
# Однако для более сложных операций лучше использовать обычные функции, определенные с помощью def.
# Пример использования lambda функции для сортировки списка словарей по значению ключа


# Встроенные функции
# abs() - возвращает абсолютное значение числа
# all() - возвращает True, если все элементы итерируемого объекта истинны
# any() - возвращает True, если хотя бы один элемент итерируемого объекта истинен
# ascii() - возвращает строковое представление объекта, используя только ASCII символы
# bin() - возвращает бинарное представление целого числа
# bool() - преобразует значение в булев тип (True или False)
# bytearray() - возвращает массив байтов
# bytes() - возвращает неизменяемый массив байтов
# callable() - проверяет, является ли объект вызываемым (функцией)
# min() - возвращает минимальное значение из итерируемого объекта
# max() - возвращает максимальное значение из итерируемого объекта
# chr() - возвращает символ по его Unicode коду
# ord() - возвращает Unicode код символа

# Новая тема
# Lambda функции или же анонимные функции или же функами без имени
# встроенные функцин
# sum() суммирует числа
# тар() применяет функцию к каждому элементу
#filter() оставляет только те элементы, где функция Тгиe
# sorted() сортирует список по заданному правилу
#max() min() максимальное и минимальное
# any() all() проверяет есть ли хоть одно Тrue или все True
# zip() Объединяет списки в пары
# enumerate() - нумерует элементы списка
# pow() - возводит число в степень
# round() - округляет число
# map() - применяет функцию ко всем элементам итерируемого объекта
# filter() - фильтрует элементы итерируемого объекта по условию
# sorted() - сортирует элементы итерируемого объекта по заданному ключу
# lambda - создает анонимные функции


# 1 Отфилтровать заказы длинее 4 символов
orders = ["apple", "banana", "kiwi", "pear", "grape", "orange"]
long_orders = list(filter(lambda order: len(order) > 4, orders))
print(long_orders)  

# 2 заказы начинаюшиеся на букву 'a'
orders = ["apple", "banana", "kiwi", "pear", "grape", "orange"]
a_orders = list(filter(lambda order: order.startswith('a'), orders))

# 3 преобразовать все заказы в верхний регистр
orders = ["apple", "banana", "kiwi", "pear", "grape", "orange"]
upper_orders = list(map(lambda order: order.upper(), orders))
print(upper_orders)






                                           # 20.10.2025 понедельник

# Работа с файлами
# Файл - это место на компьютере, где хранятся данные.
# Открытие файла - это процесс получения доступа к файлу для чтения или записи данных.
# Закрытие файла - это процесс завершения работы с файлом и освобождения ресурсов.
# Чтение файла - это процесс получения данных из файла.
# Запись в файл - это процесс добавления или изменения данных в файле.
# Схема работы с файлами:
# 1. Открыть файл с помощью функции open()
# 2. Выполнить операции чтения или записи
# 3. Закрыть файл с помощью метода close()
# Пример:
# Открытие файла для чтения
file = open("example.txt", "r")  # "r" - режим чтения
# Чтение содержимого файла
content = file.read()
print(content)
# Закрытие файла
file.close()
# Пример:
# Открытие файла для записи
file = open("example.txt", "w")  # "w" - режим записи
# Запись данных в файл
file.write("Hello, World!\n")
file.write("This is a test file.\n")
# Закрытие файла
file.close()
# Режимы открытия файлов:
# "r" - чтение (read) - открывает файл для чтения. Если
# файл не существует, возникает ошибка.
# "w" - запись (write) - открывает файл для записи. Если файл существует
# , его содержимое будет удалено. Если файл не существует, он будет создан.
# "a" - добавление (append) - открывает файл для добавления данных в
# конец файла. Если файл не существует, он будет создан.
# "r+" - чтение и запись (read and write) - открывает файл для
# чтения и записи. Если файл не существует, возникает ошибка.
# "w+" - запись и чтение (write and read) - открывает файл для
# записи и чтения. Если файл существует, его содержимое будет удалено.
# Если файл не существует, он будет создан.
# "a+" - добавление и чтение (append and read) - открывает файл
# для добавления данных в конец файла и чтения. Если файл не существует,
# он будет создан.
# Методы для работы с файлами:
# read(size) - читает указанное количество байтов из файла. Если size не
# указан, читает весь файл.
# readline() - читает одну строку из файла.
# readlines() - читает все строки из файла и возвращает их в виде списка.
# write(string) - записывает строку в файл.
# writelines(list) - записывает список строк в файл.
# close() - закрывает файл.
# Пример чтения файла построчно
file = open("example.txt", "r")
for line in file:
    print(line.strip())  # strip() удаляет лишние пробелы и символы новой строки
file.close()
# Пример добавления данных в файл
file = open("example.txt", "a")
file.write("Добавленная строка\n")
file.close()
# Пример использования with для автоматического закрытия файла
with open("example.txt", "r") as file:
    content = file.read()
    print(content)
# В этом примере файл автоматически закрывается после выхода из блока with.
# Пример записи данных в файл с помощью with
with open("example.txt", "w") as file:
    file.write("Новая строка 1\n")
    file.write("Новая строка 2\n")
# Файлы - это способ хранения данных на компьютере.
# Работа с файлами включает открытие, чтение, запись и закрытие файлов.










                                                                       # 21. 10.2025 вторник

# ООП - объектно ориентированное программирование :
  # наследование - создание нового класса на основе существующего
  # инкапсуляция - скрытие данных внутри
  # полиморфизм - один интерфейс, разные реализации
  # абстракция - выделение общих черт, скрытие деталей


# Класс - это шаблон для создания объектов. Он определяет свойства и методы, которые будут у объектов этого класса.

class Cat:#название класса с большой буквы всегда
    def __init__(self, name, age):# Конструкция класса # магический метод инициализации __init__ через два нижних подчеркивания с начала и конца 
        self.name = name # атрибуты класса
        self.age = age # атрибуты класса
    def info(self):
        return f"Кот {self.name}, возраст {self.age} лет." # метод класса
cat1 = Cat("Whiskers", 3)
print(cat1.name)  # Выведет: Whiskers
print(cat1.age)   # Выведет: 3
print(cat1.info())  # Выведет: Кот Whiskers, возраст 3 лет.


# self принадлежность - это ссылка на текущий объект класса. Он используется для доступа к свойствам и методам объекта внутри класса.
# __init__ - это специальный метод класса, который вызывается при создании нового объекта класса. Он используется для инициализации свойств объекта.

# Пример функции
car1_brand = "Toyota"
car1_year = 2020
car2_brand = "Honda"
car2_year = 2019
car3_brand = "Ford"
car3_year = 2018

def start_car(brand, year):
    print(f" {brand} стартанула , а она {year} года.")

start_car(car1_brand, car1_year)
start_car(car2_brand, car2_year)
start_car(car3_brand, car3_year)

# Пример класса
class Car:
    def __init__(self, brand, year, model, speed, cost):
        self.brand = brand
        self.year = year
        self.model = model
        self.speed = speed
        self.cost = cost
        self.going = False

    def car_is_started(self, kmH):
        self.speed = kmH
        self.going = True
        print(f"{self.brand} стартанула , а она {self.year} года , скорость {self.speed} км/ч.")

    def car_is_stopped(self):
        self.going = False
        print(f"{self.brand} остановилась.")

    def info(self):
        print(f"Бренд: {self.brand}, Модель: {self.model}, Год: {self.year}, Скорость: {self.speed} км/ч, Стоимость: {self.cost}")
car1 = Car("Toyota", 2020, "Camry", 120, 30000)
car2 = Car("Honda", 2019, "Accord", 130, 28000)
car3 = Car("Ford", 2018, "Focus", 140, 25000)
car1.info()
car2.info()
car3.info()

# Классы помогают организовать код, делают его более читаемым и позволяют создавать множество объектов с одинаковыми свойствами и методами.

                                                      #  23.10.2025 четверг

# Наследование - это механизм в объектно-ориентированном программировании, который позволяет создавать новый класс на основе существующего класса. Новый класс называется дочерним (или подклассом), а существующий класс - родительским (или суперклассом). Дочерний класс наследует свойства и методы родительского класса, что позволяет повторно использовать код и расширять функциональность.

class Animal: # Родительский класс . У которого общие параметры для всех дочерних классов
    def __init__(self, name, age, color,gender): # параметры
        self.name = name # атрибуты
        self.age = age
        self.color = color
        self.gender = gender
      # метод
    def set_name(self, new_name):
        self.name = new_name
    def info (self):
        print(f"Имя: {self.name}, Возраст: {self.age}, Цвет: {self.color}, Пол: {self.gender}")

class Cat(Animal): # Дочерний класс
    def mau(self):
        print("Мяу мяу!")

class Dog(Animal): # Дочерний класс
    def gav(self):
        print("Гав гав!")

class Lion(Animal): # Дочерний класс
    def roar(self):
        print("Рррр!")

cat1 = Cat("Барсик", 3, "рыжий","самец")
dog1 = Dog("Шарик", 5, "черный","самец")
lion1 = Lion("Симба", 7, "золотой","самец")
lion2 = Lion("Нала", 6, "золотой","самка")
lion3 = Lion("Муфаса", 10, "темно-золотой","самец")
lion3.set_name("Шрам")
cat1.mau()
dog1.gav()
lion1.roar()
cat1.info()
dog1.info()
lion1.info()
lion2.info()
lion3.info()



# Инкапсуляция - это принцип объектно-ориентированного программирования, который заключается в скрытии внутренней реализации объекта и предоставлении доступа к его данным и методам только через определённый интерфейс. Это помогает защитить данные от неправильного использования и обеспечивает контроль над тем, как они изменяются.

# Инкапсуляция - это скрытие данных внутри класса. 
# Инкапсуляция - это скрытые и защита обьекта , как к атрибутам , и методам класса.
# public - открытые (доступны везде)
# _protected - защищенные (доступны внутри класса и его подклассов)
# __private - приватные (доступны только внутри класса)

class Animal: # Родительский класс . У которого общие параметры для всех дочерних классов
    def __init__(self, name, age, color,gender): # параметры
        self.name = name # атрибуты
        self.__age = age
        self.color = color
        self.gender = gender
      # декоратор @property - это способ создать геттер для приватного атрибута
    @property
    def age(self):#getter- метод для получения приватного значения
        return self.__age

    @age.setter #setter - метод для изменения приватного значения
    def age(self, new_age):
        if new_age > 0 and new_age < 20:
          self.__age = new_age
          return self.__age
        else:
            print("Недопустимый возраст")

      # метод
    def set_name(self, new_name):
        self.name = new_name
    def info (self):
        print(f"Имя: {self.name}, Возраст: {self.age}, Цвет: {self.color}, Пол: {self.gender}")

class Cat(Animal): # Дочерний класс
    def mau(self):
        print("Мяу мяу!")

class Dog(Animal): # Дочерний класс
    def gav(self):
        print("Гав гав!")

class Lion(Animal): # Дочерний класс
    def roar(self):
        print("Рррр!")

cat1 = Cat("Барсик", 3, "рыжий","самец")
dog1 = Dog("Шарик", 5, "черный","самец")
lion1 = Lion("Симба", 7, "золотой","самец")
lion2 = Lion("Нала", 6, "золотой","самка")
lion3 = Lion("Муфаса", 10, "темно-золотой","самец")
cat1.age = 4  # изменение возраста через сеттер
print(cat1.age)  # получение возраста через геттер

#  без привата можно было бы изменить напрямую
# cat1.age = -5  # неправильное изменение возраста
# print(cat1.age)  # неправильное получение возраста
# и это бы сломало логику программы







#                                                                         # 10.11.2025 понедельник
# Тернарный оператор - это сокращённая форма условного оператора if-else, которая позволяет записать условие и его результат в одну строку. Он используется для выбора одного из двух значений в зависимости от истинности условия.
# Синтаксис тернарного оператора:
# результат_если_истина if условие else результат_если_ложь
# Пример:
age = 20
status = "Взрослый" if age >= 18 else "Ребёнок"
print(status)  # Выведет: Взрослый
# В этом примере, если возраст (age) больше или равен 18, переменная status получит значение "Взрослый". В противном случае, она получит значение "Ребёнок".

# Пример 2
is_fast = True
if is_fast:
    car = "Ferrari"
else:
    car = "Tico"
print(car) 
# Пример с тернарным оператором
print("Ferrari" if is_fast else "Tico")  # Выведет: Ferrari


# Тернарный оператор полезен для сокращения кода и повышения его читаемости, особенно когда нужно быстро выбрать между двумя значениями на основе условия.

# Пример 3
a,b,c = 5,10,15  #множественное присваивание
print(a if a > b and a > c else b if b > c else c)  # Выведет: 15


# Генераторы списков - это компактный способ создания списков в Python с использованием синтаксиса, похожего на математическую запись множеств. Они позволяют создавать новые списки, применяя выражение к каждому элементу итерируемого объекта (например, списка или диапазона) и, при необходимости, фильтруя элементы по условию.
# Синтаксис генератора списков:
# [выражение for элемент in итерируемый_объект if условие]
# Пример:
squares = [x ** 2 for x in range(10)]  # Создаёт список квадратов чисел от 0 до 9
print(squares)  # Выведет: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
# В этом примере генератор списков создаёт новый список, в котором каждый элемент является

# пример 2

data = []
for i in range(100):
    if i % 2 == 0:
        data.append(i)
print(data)


# пример с генератором списков
data = [i for i in range(100) if i % 2 == 0]
print(data)





# *args и **kwargs - это специальные синтаксические конструкции в Python, которые позволяют передавать переменное количество аргументов в функции.
# *args - arguments - используется для передачи неименованных позиционных аргументов в функцию. Он собирает все дополнительные позиционные аргументы в кортеж.
# **kwargs - keyword arguments - используется для передачи именованных аргументов в функцию. Он собирает все дополнительные именованные аргументы в словарь.
# Пример использования *args:
def sum2 (*args):
    total = 0
    for i in args:
        total += i
print(sum2(1, 2, 3, 4, 5))  # Выведет: 15



# Пример использования **kwargs:
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=30, city="New York")

# Выведет:
# name: Alice
# age: 30
# city: New York
# Использование *args и **kwargs позволяет создавать более гибкие функции, которые могут принимать разное количество аргументов в зависимости от потребностей вызова.

# Пример 3:
a = [1,2,3,4]
b = [5,6,7,8]
print(b)


# Пример 3

def combine(*args, **kwargs):
    combined_list = []
    for lst in args:
        combined_list.extend(lst)
    for key, value in kwargs.items():
        combined_list.append((key, value))
    return combined_list
result = combine([1, 2], [3, 4], name="Alice", age=30)
print(result)  # Выведет: [1, 2, 3,
# 4, ('name', 'Alice'), ('age', 30)]
# В этом примере функция combine принимает любое количество списков и именованных аргументов, объединяя их в один список.

# Пример 4
def printPoint(student,*args):
    print("Student:", student)
    for point in args:
        print("Point:", point)
printPoint("Ahmed", 85, 90, 78)

# Выведет:
# Student: Ahmed
# Point: 85
# Point: 90
# Point: 78

# **kwargs - keyword arguments- dict - словарь
def show(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

show(name="Alua", age=22, city="Bishkek")
# Выведет:
# name: Alua
# age: 22
# city: Bishkek
# В этом примере функция show принимает любое количество именованных аргументов и выводит их в формате "ключ: значение". 


def pets(owner, **kwargs):
    print("Owner:", owner)
    for pet, name in kwargs.items():
        print(f"{pet}: {name}")

pets("Ahmed", cat="Whiskers", dog="Buddy", eats="fish, meat`")
# Выведет:
# Owner: Ahmed
# cat: Whiskers
# dog: Buddy
# eats: fish, meat`

# В этом примере функция pets принимает имя владельца и любое количество именованных аргументов, представляющих питомцев и их имена.
# Задача 1 
my_str = "wdscjfwd6ehrhehf56jhfnnv576"
nums = [int(i) for i in my_str if i.isdigit()]
print(nums)  # Выведет: [6, 5, 5, 7, 6]


# Задача 1 
my_str = "wdscjfwd6ehrhehf56jhfnnv576"
nums = [int(i) for i in my_str if i.isdigit()]
print(nums)



##############################

import re # Регулярные выражения
my_str = "wdscjfwd6ehrhehf56jhfnnv576"
nums = re.findall("[0-9]", my_str)
numbers = []
for i in nums:
    numbers.append(int(i))
print(numbers)


##############################


nums = []
tem = ""
for i in my_str:
    if i.isdigit():
        tem += i 
    else:
        if tem != "":
            nums.append(int(tem))
            tem = ""
if tem :
    nums.append(int(tem))
print(nums)







                                                                 #  Декораторы
# Декоратор - это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию с расширенным поведением. Декораторы позволяют добавлять функциональность к существующим функциям без изменения их кода.
# Синтаксис декоратора:
# @имя_декоратора
# def имя_функции(аргументы):
    # тело функции
# Пример декоратора:
def decorator_function(original_function):
    def wrapper_function(*args, **kwargs):
        print("Перед вызовом функции")
        result = original_function(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper_function
@decorator_function
def say_hello(name):
    print(f"Привет, {name}!")
say_hello("Ахмед")
# Выведет:
# Перед вызовом функции
# Привет, Ахмед!
# После вызова функции
# В этом примере декоратор decorator_function добавляет вывод сообщений перед и после вызова функции say_hello.
# Декораторы полезны для:
# 1. Логирования вызовов функций.
# 2. Измерения времени выполнения функций.
# 3. Проверки прав доступа.
# 4. Кэширования результатов функций.
# 5. Добавления функциональности к функциям без изменения их кода.
# Пример декоратора для измерения времени выполнения функции
import time
def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения: {end_time - start_time} секунд")
        return result
    return wrapper
@timer_decorator
def compute_square(n):
    return n ** 2
print(compute_square(10))
# Выведет:
# Время выполнения: 1.1920928955078125e-06 секунд
# 100
# В этом примере декоратор timer_decorator измеряет время выполнения функции compute_square и выводит его на экран.
# Декораторы - мощный инструмент в Python, который позволяет расширять функциональность функций и улучшать структуру кода.





# Декораторы добовляют функсиональность в существующий код 
# Декоратор - это паттерн програмирование , который позволяет добовлять НОВЫЙ ФУНКЦИОНАЛ В СУЩЕСТВУЮЩИЙ КОД

def gre():
    print("Hello")

hello = gre  # присваиваем функцию другой переменной
hello()  # вызываем функцию через новую переменную

################

def gromko(text):
    return text.upper()

def tixo(text):
    return text.lower()

def speaker(func):  # декоратор
    massage = func("Hello PKS-01-25")
    print(massage)

speaker(gromko)  # вызов с громкой функцией
speaker(tixo)    # вызов с тихой функцией



# пример с декоратором
def inc(x):
    return x * 2

def dec(x):
    return x / 2

def oper(func, x):
    result = func(x)
    return result

print(oper(inc, 10))  # Выведет: 20
print(oper(dec, 10))  # Выведет: 5.0

# пример с декоратором через @
def before_after(func):
    def wrapper(*args, **kwargs):
        print("Перед вызовом функции")
        # result = func(*args, **kwargs)
        func()
        print("После вызова функции")
    
    return wrapper

@before_after
def say_hi():
    print("Привет!")

say_hi()
# Выведет: 
# Перед вызовом функции
# Привет!
# После вызова функции

# пример 2 с декоратором через @

def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__} с аргументами {args} и {kwargs}")
        res = func(*args, **kwargs)
        print(f"Функция {func.__name__} вернула {res}")
        return res
    return wrapper
@logger
def add(*args, **kwargs):
    return sum(args) + sum(kwargs.values())


add(1, 2, 3)
add(n=4, g=5)
add(1, 2, n=3, g=4)




# @property - это декоратор в Python, который позволяет создавать свойства класса. Свойства - это специальные методы, которые ведут себя как атрибуты, но при этом могут выполнять дополнительную логику при получении или установке значения.
# С помощью @property можно определить геттер (метод для получения значения) и сеттер (метод для установки значения) для атрибута класса.
###########
# @property - это встроенный декоратор 
#     getter - получение
#     setter - изменение
#     deleter - удаление
# Позволяет нам обращаться к методу как к полю атрибута

# без @property
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    def get_area(self):
        return 3.14 * self._radius ** 2
    
c = Circle(5)
print(c.get_area())  # Выведет: 78.5

#####################################
class Person:
    def __init__ (self,name):
        self.__name = name
    @property
    def name(self):
        return self.__name
    @name.setter
    def name(self,value):
        print("Сеттер сработал")
        if not isinstance(value,str):
            raise ValueError("Имя должно быть строкой")
        self.__name = value
    @name.deleter
    def name(self):
        print("Делетер сработал")
        del self.__name 

p = Person("Ahmed")
p.name = "Alua"  # вызов сеттера
print(p.name)    # вызов геттера
del p.name      # вызов делетера